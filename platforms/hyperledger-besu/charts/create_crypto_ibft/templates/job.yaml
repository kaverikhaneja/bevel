---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.metadata.name }}
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app: {{ .Values.metadata.name }}
    app.kubernetes.io/name: {{ .Values.metadata.name }}
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}		
    app.kubernetes.io/managed-by: {{ .Release.Service }}			
    app.kubernetes.io/instance: {{ .Release.Name }}			
spec:
    backoffLimit: 6
    template:
      metadata:
        labels:
          app: {{ .Values.metadata.name }}
          app.kubernetes.io/name: {{ .Values.metadata.name }}
          helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
          app.kubernetes.io/managed-by: {{ .Release.Service }}
          app.kubernetes.io/instance: {{ .Release.Name }}
      spec:
        restartPolicy: "OnFailure"
        serviceAccountName: {{ .Values.vault.serviceaccountname }}
        volumes:
          - name: cryptocheck
            emptyDir:
              medium: Memory
          - name: genesis-raw-config
            configMap:
              name: genesis-{{ .Values.configMap.name }}
              items:
                - key: ibftConfigFile.json
                  path: ibftConfigFile.json
        initContainers:
        - name: init-check-crypto
          image: {{ .Values.image.initContainerImage }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          volumeMounts:
          - mountPath: /cryptocheck
            name: cryptocheck
          env:
            - name: VAULT_ADDR
              value: {{ .Values.vault.address }}
            - name: VAULT_APP_ROLE
              value: {{ .Values.vault.role }}
            - name: KUBERNETES_AUTH_PATH
              value: {{ .Values.vault.authpath }}
            - name: VAULT_SECRET_PREFIX
              value: {{ .Values.vault.ibftprefix }}
            - name: MOUNT_PATH
              value: "/cryptocheck"
            - name: ITEM_NAME
              value: {{ .Values.metadata.item.name}}
          command: ["sh", "-c"]
          args:
          - |-
            #!/usr/bin/env sh
            validateVaultResponse () {
              if echo ${2} | grep "errors"; then
                echo "ERROR: unable to retrieve ${1}: ${2}"
                exit 1
              fi
              if  [ "$3" == "LOOKUPSECRETRESPONSE" ];
              then
                http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
                --header "X-Vault-Token: ${VAULT_TOKEN}" \
                ${VAULT_ADDR}/v1/${1})
                curl_response=$?
                if test "$http_code" != "200" ; then
                  echo "Http response code from Vault - $http_code and curl_response - $curl_response"
                  if test "$curl_response" != "0"; then
                    echo "Error: curl command failed with error code - $curl_response"
                    exit 1
                  fi
                fi
              fi
            }

            #Setting up the environment to check and get secrets from Vault
            echo "Getting secrets from Vault server: ${VAULT_ADDR}"
            KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
            VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
            validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
            echo "Logged into Vault"
              
            mkdir -p ${MOUNT_PATH}

            LOOKUP_SECRET_RESPONSE=$(curl -sS -H "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${VAULT_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
            if echo ${LOOKUP_SECRET_RESPONSE} | grep "errors"
            then
              echo "Crypto absent in vault. Ignore error warning"
              touch ${MOUNT_PATH}/absent.txt
            else
              validateVaultResponse "${VAULT_SECRET_PREFIX}" "${LOOKUP_SECRET_RESPONSE}" "LOOKUPSECRETRESPONSE"
              echo "Crypto present in vault."
              VAULT_RESULT=$(echo ${LOOKUP_SECRET_RESPONSE})
              touch ${MOUNT_PATH}/present.txt
            fi
            echo "Done checking for secrets in vault"
        containers:
        - name: crypto-ibft
          image: {{ .Values.image.repository }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          volumeMounts:
          - mountPath: /cryptocheck
            name: cryptocheck 
          - mountPath: /genesis-raw-config                             
            name: genesis-raw-config
          env:
            - name: NODE_NAME
              value: {{ .Values.node.name }}
            - name: NODE_ORG
              value: {{ .Values.node.org }}
            - name: NODE_TYPE
              value: {{ .Values.node.type }}
            - name: COMPONENT_NAME
              value: {{ .Values.metadata.name }}
            - name: VAULT_SECRET_PREFIX
              value: {{ .Values.vault.ibftprefix }}
            - name: VAULT_ADDR
              value: {{ .Values.vault.address }}
            - name: KUBERNETES_AUTH_PATH
              value: {{ .Values.vault.authpath }}
            - name: VAULT_APP_ROLE
              value: {{ .Values.vault.role }}
            - name: PEER_NAME
              value: {{ .Values.metadata.peer.name }}
          command: ["/bin/bash", "-c"]
          args:
          - |-
            #installing jq
            curl -L -o /opt/besu/bin/jq https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64
            chmod +x /opt/besu/bin/jq
            jq --version

            validateVaultResponse () {
                if echo ${2} | grep "errors"; then
                  echo "ERROR: unable to retrieve ${1}: ${2}"
                  exit 1
                fi
                if  [ "$3" == "LOOKUPSECRETRESPONSE" ];
                then
                  http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
                  --header "X-Vault-Token: ${VAULT_TOKEN}" \
                  ${VAULT_ADDR}/v1/${1})
                  curl_response=$?
                  if test "$http_code" != "200" ; then
                    echo "Http response code from Vault - $http_code and curl_response - $curl_response"
                    if test "$curl_response" != "0"; then
                      echo "Error: curl command failed with error code - $curl_response"
                      exit 1
                    fi
                  fi
                fi
              }
            
            if [ -e /cryptocheck/present.txt ]
            then
              echo "Crypto Material already present in the vault."
              exit 0
            fi
            
            #Create build folder to store crypto material
            BUILD_PATH="build"
            mkdir -p ${BUILD_PATH}
          
            #Get information about each node from network.yaml and store it in an array
            declare -a node
            declare -a nodeOrg
            declare -a nodeType

            node+=(${NODE_NAME})
            nodeOrg+=(${NODE_ORG})
            nodeType+=(${NODE_TYPE})
            
            # for data in "${org[@]}";
            # do
            #   nodeOrg+=(${data[name]})
            #   nodeType+=(${data[type]})
            #   if [${data.services.validators}]
            #   then
            #     node+=(${data.services.validators.validator.name})
            #     echo "node_name = ${node[@]}"
            #   else
            #     node+=(${data.services.peers.peer.name})
            #     echo "node_name = ${node[@]}"
            #   fi
            # done
            
            #Generate crypto for IBFT consensus
            echo "Generating crypto for IBFT consensus"
            /opt/besu/bin/besu operator generate-blockchain-config  --config-file=/genesis-raw-config/ibftConfigFile.json --to=${BUILD_PATH}/crypto  --private-key-file-name=key
            
            #Find folders created by besu in the above command, and rename them with node information
            declare -a FILE_PATH
            declare -a DEST

            for folder in $(find ${BUILD_PATH}/crypto/keys -maxdepth 1 -mindepth 1 -type d);
            do
              echo "Folders: ${folder}"
              FILE_PATH+=(${folder})
            done

            for i in "${!node[@]}";
            do
              mkdir -p ${BUILD_PATH}/crypto/${nodeOrg[i]}/${node[i]}
              DEST+=(${BUILD_PATH}/crypto/${nodeOrg[i]}/${node[i]}/data)
            done
    
            #rename the directories
            for i in "${!folder[@]}";
            do
              mv ${FILE_PATH[i]} ${DEST[i]}
              echo "Destination files:"
              ls -l ${DEST[i]}/

              #Save the keys to vault
              echo "Copying keys to vault..."
              #Setting up env to login vault
              KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
              validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
              echo "Logged into Vault"

              #Copy the crypto material to Vault
              LOOKUP_SECRET_RESPONSE=$(curl -sS -H "X-Vault-Token: ${VAULT_TOKEN}" \
                -H "Content-Type: application/json" \
                -X POST \
                -d '{"key":"'"$(cat ${DEST[i]}/key)"'"}' ${VAULT_ADDR}/v1/${VAULT_SECRET_PREFIX}/${node[i]}/data | jq -r 'if .errors then . else .auth.client_token end')

              #Copy the crypto material to Vault
              LOOKUP_SECRET_RESPONSE=$(curl -sS -H "X-Vault-Token: ${VAULT_TOKEN}" \
                -H "Content-Type: application/json" \
                -X POST \
                -d '{"key_pub":"'"$(cat ${DEST[i]}/key.pub)"'"}' ${VAULT_ADDR}/v1/${VAULT_SECRET_PREFIX}/${node[i]}/data | jq -r 'if .errors then . else .auth.client_token end')
            done
            echo "Saved the keys in vault"

            #create file to store addresses of validator nodes
            touch ${BUILD_PATH}/validatorinfo
            
            #Generate node address for each node
            for i in "${!node[@]}";
            do
              data_path=${BUILD_PATH}/crypto/${nodeOrg[i]}/${node[i]}/data
              export_address=${data_path}/nodeAddress
              echo "Generating node address..."
              /opt/besu/bin/besu --data-path ${data_path} public-key export-address --to=${export_address}

              echo "Check key files for ${node[i]}"
              ls -l /opt/besu/build/crypto/${nodeOrg[i]}/${node[i]}/data/

              echo "Check nodeAddress content for ${node[i]}:"
              cat ${export_address}
              
              base64 ${export_address} > nodeAddress_base64
              echo "base 64 encoded node address for ${node[i]}:"
              cat nodeAddress_base64

              #Save the node addresses in vault
              echo "Copying node addresses to vault..."
              #Setting up env to login vault
              KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
              validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
              echo "Logged into Vault"

              #Copy the crypto material to Vault
              LOOKUP_SECRET_RESPONSE=$(curl -sS -H "X-Vault-Token: ${VAULT_TOKEN}" \
                -H "Content-Type: application/json" \
                -X POST \
                -d '{"nodeAddress_base64":"'"$(cat ${export_address})"'"}' ${VAULT_ADDR}/v1/${VAULT_SECRET_PREFIX}/${node[i]}/data | jq -r 'if .errors then . else .auth.client_token end')
               echo "Copied the node addresses to vault"

              # if [${ADD_NEW_ORG} == "True"]; then
              #   #generate the node public key for each peer of new organization
              #   export_key_path=${BUILD_PATH}/crypto/${nodeOrg[i]}/${node[i]}/data/key.pub
              #   /opt/besu/bin/besu --data-path ${data_path} public-key export --to=${export_key_path}
              # fi

              #Create the validator address array
              if [[ ${nodeType[i]} == "validator" ]]; then
                echo "\"$(cat ${export_address})\"" >> ${BUILD_PATH}/validatorinfo
              fi
            done
            
            echo "Checking validator info array for validator:"
            cat ${BUILD_PATH}/validatorinfo

            #toEncode.json file is used by besu binary to generate the extra data information
            touch ${BUILD_PATH}/toEncode.json
            touch ${BUILD_PATH}/extraData
            ls -l ${BUILD_PATH}/

            #New genesis file with extradata information
            touch ${BUILD_PATH}/crypto/newGenesis.json
            ls -l ${BUILD_PATH}/crypto

            #create the rlp encoded string and add it to extraData field in newGenesis.json
            cat ${BUILD_PATH}/validatorinfo | paste -sd "," -| awk '{print "["$0"]"}'> ${BUILD_PATH}/toEncode.json
            
            echo "validator address json:"
            cat ${BUILD_PATH}/toEncode.json
            
            echo "extra data:"
            besu rlp encode --from=${BUILD_PATH}/toEncode.json --to=${BUILD_PATH}/extraData

            cat ${BUILD_PATH}/extraData

            # echo "$(/opt/besu/bin/besu rlp encode --from=${BUILD_PATH}/toEncode.json)" > ${BUILD_PATH}/extraData
            # jq '.extraData = $newVal' --arg newVal $(cat ${BUILD_PATH}/extraData) << cat ${BUILD_PATH}/crypto/genesis.json > ${BUILD_PATH}/crypto/newGenesis.json
            
            # touch ${BUILD_PATH}/crypto/genesis_base64
            # base64 ${BUILD_PATH}/crypto/newGenesis.json > genesis_base64

            # echo "check genesis base64:"
            # cat genesis_base64

            # #delete the keys directory
            # rm -r ${BUILD_PATH}/crypto/keys
            # ls -l  ${BUILD_PATH}/crypto/keys
        
            #Save the modified genesis file with extra data info to vault
            # echo "Copying the genesis_base64 to vault..."

            # #Setting up env to login vault
            # KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
            # VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
            # validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
            # echo "Logged into Vault"

            # #Copy genesis to vault
            # LOOKUP_SECRET_RESPONSE=$(curl -sS -H "X-Vault-Token: ${VAULT_TOKEN}" \
            #   -H "Content-Type: application/json" \
            #   -X POST \
            #   -d '{"genesis":"'"$(cat ${BUILD_PATH}/crypto/genesis_base64)"'"}' ${VAULT_ADDR}/v1/${VAULT_SECRET_PREFIX}/genesis | jq -r 'if .errors then . else .auth.client_token end')
            #   echo "Done copying genesis to the vault"
        
       